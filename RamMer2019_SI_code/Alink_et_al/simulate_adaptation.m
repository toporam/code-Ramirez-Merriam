function [out]=simulate_adaptation(v, X, j, cond1, cond2, a, b, sigma, model_type, reset_after, paradigm)
% This function simulates fMRI repetition effects for 2 paradigms using 12
% neural models. The tuning curves are generated by Gaussian or circular
% Gaussian (von Mises) embedded functions at end.
%
% Arguments:
% v = total number of voxels,
% X = length of the stimulus dimension
% j = order of the trials (paradigm)
% cond1 and cond2 are condition types (values on stimulus dimension)
% a, b, and sigma are free parameters to be tuned
% reset_after resets the adapation amount
%
% output "out" is a pattern of trials by voxels for the order of trials
% coded by j parameter using paradigm_setting function
%
% Version 1.0   8-June-2017         Hunar.Abdulraham@mrc-cbu.cam.ac.uk

for vox=1:v;
    dt = X/180;   % stimulus dimension resolution
    x = dt:dt:X;  % stimulus dimension
    tuning_curve_peaks=[0 X/8 X*2/8 X*3/8 X/2 X*5/8 X*6/8 X*7/8]; % represents neural population types
    
    %% neuron loop
    for i=1:length(tuning_curve_peaks);
        % random sampling of neural population types
        u(i)=randsample(tuning_curve_peaks,1);
        
        % calculate the initial response
        temp=g(x,u(i),sigma, paradigm);
        init_max = max(temp);
        init(i,:)=temp/init_max;
        
        % intialize c value to 1 (no adaptation at the start)
        c=1; 
        
        % apply adapation
        for q=1:length(j);
            % distance, d, paramter in non-shifting models
            d(i,q) = u(i)-j(q);
            
            % circularise d if grating experiment
            if(strcmp(paradigm,'grating')==1);
                d(i,q) = min(abs(d(i,q)),X-abs(d(i,q)));
            end
            
            % check if it is the sart of the run
            if(rem(q-1,reset_after)==0)
                rep(q,i,:) = init(i,:);
                % initialize and reset the adatpation,c, parameter after each
                % session for the grating paradigm and after each repetition
                % for the face paradigm(because the first presentation of each
                % face is novel)
                c=1;
            else
                % global scaling
                if(model_type==1);
                    c=c*a;
                    temp=c*g(x,u(i),sigma,paradigm);
                    rep(q,i,:) = temp/init_max;
                    
                    % local scaling
                elseif(model_type==2);
                    c=c*min(1,(a+abs(d(i,q)/b)*(1-a)));
                    temp=c*g(x,u(i),sigma,paradigm);
                    rep(q,i,:) = temp/init_max;
                    
                    % remote scaling
                elseif(model_type==3);
                    c=c*max(a,(1-abs(d(i,q)/b)*(1-a)));
                    temp=c*g(x,u(i),sigma,paradigm);
                    rep(q,i,:) = temp/init_max;
                    
                    % global sharpening
                elseif(model_type==4);
                    c=c*a;
                    temp=g(x,u(i),c*sigma,paradigm);
                    rep(q,i,:) = temp/max(temp);
                    
                    % local sharpening
                elseif(model_type==5);
                    c=c*min(1,(a+abs(d(i,q)/b)*(1-a)));
                    temp=g(x,u(i),c*sigma,paradigm);
                    rep(q,i,:) =  temp/max(temp);
                    
                    % remote sharpening
                elseif(model_type==6);
                    c=c*max(a,(1-abs(d(i,q)/b)*(1-a)));
                    temp=g(x,u(i),c*sigma,paradigm);
                    rep(q,i,:) = temp/max(temp);
                    
                    % global repulsive shifting
                elseif(model_type==7);
                    kg=a;
                    c = c* (sign(d(i,q))*kg);
                    temp=g(x,u(i)+c*X/2,sigma,paradigm);
                    rep(q,i,:) = temp/max(temp);
                    
                    % local repulsive shifting
                elseif(model_type==8);
                    kl=min(1,(a+abs(d(i,q)/b)*(1-a)));
                    c = c* (sign(d(i,q))*kl);
                    temp=g(x,u(i)+c*X/2,sigma,paradigm);
                    rep(q,i,:) = temp/max(temp);
                    
                    % remote repulsive shifting
                elseif(model_type==9);
                    kr=max(a,(1-abs(d(i,q)/b)*(1-a)));
                    c = c* (sign(d(i,q))*kr);
                    temp=g(x,u(i)+c*X/2,sigma,paradigm);
                    rep(q,i,:) = temp/max(temp);
                    
                    % global attractive shifting
                elseif(model_type==10);
                    kg=a;
                    c = c* (sign(d(i,q))*kg);
                    temp=g(x,u(i)-c*X/2,sigma,paradigm);
                    rep(q,i,:) = temp/max(temp);
                    
                    % local attractive shifting
                elseif(model_type==11);
                    kl=min(1,(a+abs(d(i,q)/b)*(1-a)));
                    c = c* (sign(d(i,q))*kl);
                    temp=g(x,u(i)-c*X/2,sigma,paradigm);
                    rep(q,i,:) = temp/max(temp);
                    
                    % remote attractive shifting
                elseif(model_type==12);
                    kr=max(a,(1-abs(d(i,q)/b)*(1-a)));
                    c = c* (sign(d(i,q))*kr);
                    temp=g(x,u(i)-c*X/2,sigma,paradigm);
                    rep(q,i,:) = temp/max(temp);
                    
                end
            end
        end
    end
    store{vox}=rep;
    
    % sampling neuron activities for each condition
    for q=1:length(j);
        if(j(q)==cond1);
            activity(q,:)=rep(q,:,cond1*1/dt);
        else
            activity(q,:)=rep(q,:,cond2*1/dt);
        end
        pattern(q,vox)=mean(activity(q,:));
    end
end

%% the main output 2d matrix [t,v] =trials[conditions and presentations ordered according to j] x voxels
out.pattern=pattern;

%% just for sanity checks
out.rep=rep;
out.activity=activity;
out.store=store;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% local functions to generate guassian pdfs
function gauss=g(x, u, sigma, paradigm)

if(strcmp(paradigm,'face')==1);
    gauss = non_circular_g(x, [sigma u]);
elseif(strcmp(paradigm,'grating')==1);
    gauss = circular_g(2*x, 2*u, 1/sigma);
end

%% non circular guassian function
function y = non_circular_g(x, params)
sigma = params(1); c = params(2);
y = exp(-(x - c).^2/(2*sigma^2));

%% circular guassian function - von Mises
function y = circular_g(x, u, sigma)
x = x(:);
C = 1/(2*pi*besseli(0,sigma));
y = C * exp(sigma*cos(x-u));
